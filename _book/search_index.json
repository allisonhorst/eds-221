[["index.html", "EDS 221: SCIENTIFIC PROGRAMMING ESSENTIALS Chapter 1 Scientific programming essentials for environmental data science 1.1 Course introduction 1.2 Links to course materials 1.3 Course setup 1.4 Course resources", " EDS 221: SCIENTIFIC PROGRAMMING ESSENTIALS Allison Horst Chapter 1 Scientific programming essentials for environmental data science Material disclaimer and use This book was created by Allison Horst for EDS 221 (Scientific Programming Essentials) in the Bren School’s 1-year Master of Environmental Data Science program at UC Santa Barbara. It accompanies lecture, computational lab and discussion materials that may or may not be linked to throughout the book. This book is intended as a supplemental resource for some parts of the course. In other words, it is not intended as a standalone textbook. All materials in this book are openly available for use and reuse by Creative Commons Attribution and Share-Alike license. Thank you in advance for suggestions and corrections, which can be submitted as issue to this GitHub repo. Acknowledgments I create my courses while standing on shoulders of generous teaching and developing giants in R, data science, and education communities. The wealth and quality of open educational resources (OERs) in data science has made teaching in the field fun, innovative, and inspiring. I’ve tried to thoroughly credit authors resources that I have pulled from and adapted for this book, and I welcome additions if I have missed any that should be included. 1.1 Course introduction Figure 1.1: Slide from Dr. Julia Lowndes’ 2019 keynote talk at useR conference (illustration by Allison Horst). As nicely summarized in the title of a 2018 NCEAS post, “the next generation of environmental scientists are data scientists”. Over the next year in MEDS you’ll build skills to responsibly apply advanced methods in environmental modeling, spatial data analysis, machine learning, and more to investigate, analyze and communicate with complex environmental data. To get there, you’ll need a strong foundation in programming basics like: understanding types and structures of data, basic data wrangling and visualization, algorithm development with functions, loops, and conditionals, and how to troubleshoot. While working in the weeds of programming, we’ll also learn and reinforce transferable habits for reproducible workflows, robust file paths, version control, data organization, project management, and more. In EDS 221 you’ll also start building versatility by learning fundamental programming skills in different languages (R, Python) and integrated development environments (IDEs) like RStudio and PyCharm, while documenting our work in R Markdown and Jupyter Notebooks. Upon the building blocks established in EDS 221, you’ll be prepared to incrementally grow your advanced environmental data science toolkit throughout MEDS, then enter the workplace at the leading edge of quantitative methods in the field. 1.2 Links to course materials EDS 221 Syllabus Code of Conduct EDS 221 GitHub site 1.3 Course setup We will use the following in EDS 221. You should have pre-installed recent versions before starting the course. R (Version 4.0.2 “Taking Off Again,” or higher) RStudio Desktop (version 1.4.1103 “Wax Begonia,” or higher) RStudio Cloud account Python (version XXXXX or higher) Pycharm (version XXXX or higher) 1.4 Course resources Hands-on Programming with R by Garrett Grolemund R for Data Science by Garrett Grolemund and Hadley Wickham Advanced R by Hadley Wickham Learn Python Break Python by Scott Grant "],["r-py.html", "Chapter 2 Meet the 221 tools 2.1 R 2.2 RStudio 2.3 Python 2.4 Jupyter Notebooks", " Chapter 2 Meet the 221 tools 2.1 R 2.2 RStudio 2.3 Python 2.4 Jupyter Notebooks "],["types.html", "Chapter 3 Data structures and types 3.1 Data structures 3.2 Data types", " Chapter 3 Data structures and types How we work with data is largely dependent on the type and structure of data we’re working with. That’s more than just “is this a number or letters?” We need to understand how the data are stored so that we know how to access pieces of it, how our code will understand and interact with data, and so we’re correctly predicting how data will change based on what we do with it. In this chapter, we’ll learn about different structures of data, and the types of data they can contain. 3.1 Data structures 3.1.1 Vectors 3.1.2 Tibbles 3.1.3 Matrices 3.1.4 Lists 3.2 Data types See: https://r4ds.had.co.nz/vectors.html "],["tidydata.html", "Chapter 4 Tidy data 4.1 Common ways data are untidy 4.2 Tidy data makes coding easier 4.3 Tidy data for collaboration", " Chapter 4 Tidy data Note: all artwork in this chapter are from an illustrated collaborative Openscapes blog post by Dr. Julia Lowndes and Dr. Allison Horst (Lowndes and Horst 2020). Tidy data is a predictable way to organize data that makes it more coder and collaborator friendly. As described by Hadley Wickham, in tidy data each column is a variable, each row is an observation, and each cell contains a single value (measurement) (Wickham 2014). This may seem like a mundane topic, but tidy data provides a way of thinking about and organizing data that will become fundamental to how you input, wrangling, and work with environmental data - it becomes part of a systematic approach to working with data that will make you a better data scientist and collaborator. 4.1 Common ways data are untidy One way to understand tidy data is to consider what makes some data sets untidy. Let’s explore some examples of untidy data, and for each think about (1) why it’s untidy, and (2) how we would wrangle it to make it tidy data. 4.1.1 Untidy example 1: A single variable across multiple columns One of the most common ways that data can be untidy is if a single variable is broken up by group across multiple columns. For example, the following data contains the weights of three dogs, measured over four years: Table 4.1: Dog weight (pounds) in untidy format, where a single variable (weight) is spread out across different levels of the year variable. dog 2018 2019 2020 2021 Teddy 36.4 39.2 44.8 47.5 Khora 41.6 48.3 52.9 50.1 Waffle NA NA 20.4 23.7 In this example, there are really only 3 variables: dog name, dog weight, and year. But as organized, there are 5 columns - this should be our first indication that the data is not tidy. Instead of each variable occupying its own column, the weight measurements have been split up across multiple columns, separated by the different levels of year. Sometimes you will hear this called “wide format” when a single variable is spread across multiple columns. What would this data look like if it were tidy? To be in tidy data, each variable (dog, weight, and year) should have its own column. In this example, starting from the wide format data we need to reshape weight observations into a single column. Year will need to populate a new column, with year values repeated as necessary to align with the long-format weights. We’ll also need to repeat the dog names to accommodate the number of observations for each. Later on, we’ll hear how to reshape data from wide-to-long format (e.g. using tidyr::pivot_longer() in R), but for now think about the tidy format of the same data, shown below: Table 4.2: Dog weight (pounds) in tidy format, where each variable is in its own column. dog year weight Teddy 2018 36.4 Teddy 2019 39.2 Teddy 2020 44.8 Teddy 2021 47.5 Khora 2018 41.6 Khora 2019 48.3 Khora 2020 52.9 Khora 2021 50.1 Waffle 2018 NA Waffle 2019 NA Waffle 2020 20.4 Waffle 2021 23.7 4.1.2 Untidy example 2: multiple values in a single cell Another way that data can be untidy is if there are multiple “measurements” (or values) in a single cell. Keep in mind that a “value” doesn’t have to be numeric - it’s just a measurement or description for a recorded variable. Sometimes raw data will contain multiple values in a single cell. For example, here we see that the make, model and year of cars are all in a single column called type: Table 4.3: Car descriptions in untidy format. type color condition 1994 Toyota Corolla silver poor 2005 Subaru Outback green average 1977 Datsun 710 blue excellent An important thing is to be future-thinking about data, and expect that even if you don’t think a specific question is important now, it may be important in the future – and having data in tidy format will make it easier to answer a wider range of questions with limited frustration. For example, maybe in the future (and if this were part of a larger data set) we would want to assess the condition of cars by year, or the color of cars by make and model. No matter how you slice those questions, having each variable in its own column will make them easier to explore and answer with code. In the future, you’ll learn how to separate components of a single column into multiple columns (e.g. using the tidyr::separate() function), which in this example would help to create a tidy version of the data that looks like this: Table 4.4: Car descriptions in tidy format. year make model color condition 1994 Toyota Corolla silver poor 2005 Subaru Outback green average 1977 Datsun 710 blue excellent Untidy example 3: multiple observations in a single row Occasionally, you will see environmental data where information for multiple observations are stored in a single row. For example, this is common when research divers are estimating numbers of a certain species within different size bins. For example, a dive record may contain information like this: Table 4.5: Spiny lobster counts by size. species size_cm count spiny lobster 4.5 2 spiny lobster 5.0 4 spiny lobster 5.5 0 spiny lobster 6.0 1 spiny lobster 6.5 3 So in this case, we have multiple lobster observations occupying single rows (e.g. the second row actually contains data for four lobsters). On the spectrum of untidy data, this isn’t too bad - but it can make it much easier (and less risky) to visualize and analyze the data if each observation is in its own row. We’ll learn how to convert a frequency table (like this one, which contains counts) into case format (which does have a single row per observation, so that the data look something like this: species size_cm spiny lobster 4.5 spiny lobster 4.5 spiny lobster 5.0 spiny lobster 5.0 spiny lobster 5.0 spiny lobster 5.0 spiny lobster 6.0 spiny lobster 6.5 spiny lobster 6.5 spiny lobster 6.5 Now, each individual lobster occupies its own row, and the data are in tidy format. 4.2 Tidy data makes coding easier The process of creating tidy data is useful in an of itself, because it requires us to be deliberate and thoughtful about how we structure our data, and makes us define our variables, observations and measurements. We will learn why that benefits us and our collaborators in the next section. Here, let’s learn why tidy data is code- and coder-friendly. 4.2.1 Code working for you 4.2.2 Parse &amp; explore 4.2.3 Safer summary statistics 4.3 Tidy data for collaboration "],["basic-wrangling.html", "Chapter 5 Basic wrangling", " Chapter 5 Basic wrangling Indexing, subsetting, etc. "],["logicals.html", "Chapter 6 Logical operators", " Chapter 6 Logical operators "],["conditionals.html", "Chapter 7 Conditionals", " Chapter 7 Conditionals "],["iteration.html", "Chapter 8 Iteration 8.1 Iteration in programming 8.2 Generic for loop anatomy 8.3 Basic for loops in R and Python 8.4 Iteration with conditions 8.5 While loop 8.6 R / Python side-by-side comparisons", " Chapter 8 Iteration From Miriam-Webster Dictionary: \"Iteration: (noun) the action or a process of iterating or repeating, such as: a procedure in which repetition of a sequence of operations yields results successively closer to a desired result the repetition of a sequence of computer instructions a specified number of times or until a condition is met\" 8.1 Iteration in programming In programming, iteration is repeating instructions. Usually it’s to spare yourself from having to manually do a repetitious thing. Well-written iteration can also make code more readable, usable, and efficient (definitely to write, sometimes to run). For example, let’s consider a few scenarios that may prompt you to use iteration: Your data contains 382 columns (variables), and you want to find the mean and standard deviation for each variable You have 250 csv files and you want to read them all in and combine them into a single data frame In a single data frame you have annual observations for fish passage from 1970 - 2019 recorded at 25 dams in Oregon, and you want to create and save a single graph for passage at each dam …so basically, anything where you’re like “Welp, I guess I’m going to be doing the same thing over and over and over and over…” should inspire you to consider iteration. 8.1.1 A real-world example of iteration in environmental data science 8.2 Generic for loop anatomy When we iterate in code, most often that means we’re writing some version of a for loop, which we can read as “For these elements in this thing, do this thing to each and return the output, then move on to the next element until you reach the end or a stopping point.” There are a bunch of variations on that, but that’s the overarching idea. For example, in the image below our vector is a parade of friendly monsters getting passed through a for loop. There are conditions within the for loop dictating which type of accessory each monster will get, based on their shape. Then the outcome is returned with print(). Monsters passing through a for loop, getting assigned sunglasses or a hat based on their shape. In words, how can we describe what’s happening in this for loop? As each monster is passed individually through the loop, if it is a triangle, then it gets sunglasses added to it – that’s why the first element in the output vector is a triangle monster with sunglasses. Then we move on to the second (orange) monster. Since they are also a triangle, they’re assigned sunglasses. However, when we get to the third (purple) monster, it is not a triangle, and anything monster shape other than a triangle is assigned a hat - so we see the third output is the purple circle monster with a hat. …and so on until all elements have been passed through the for loop or a stopping point is otherwise reached. 8.2.1 Anatomy of a for loop 8.3 Basic for loops in R and Python Let’s take a look at some basic for loops, written in both R and Python. 8.3.0.1 Example: A vector of very good dogs Here’s our scenario: starting with a vector of dog names “Teddy,” “Khora,” and “Waffle,” write a for loop that returns the statement “[dog name here] is a very good dog!” In R: # Create the vector of names: dog_names &lt;- c(&quot;Teddy&quot;, &quot;Khora&quot;, &quot;Waffle&quot;) # Run it through the loop: for (i in dog_names) { print(paste(i, &quot;is a very good dog!&quot;)) } ## [1] &quot;Teddy is a very good dog!&quot; ## [1] &quot;Khora is a very good dog!&quot; ## [1] &quot;Waffle is a very good dog!&quot; In Python: # Create the vector of names: dog_names = [&#39;Teddy&#39;, &#39;Khora&#39;, &#39;Waffle&#39;] # Run it through the for loop: for i in dog_names: print(i + &quot; is a very good dog!&quot;) ## Teddy is a very good dog! ## Khora is a very good dog! ## Waffle is a very good dog! Note that there’s nothing special about i here - that’s just an identifier for “each element in this vector.” It can be whatever object name you want, but make sure you’re referring to the correct thing later on in the loop body. For example, that code could have been written in R as: for (treats in dog_names) { print(paste(treats, &quot;is a very good dog!&quot;)) } 8.3.0.2 Example: Hypotenuses! For a vector of values 2, 3, 4, 5, 6, 7, for any two sequential values, find the length of the hypotenuse if the two values are the lengths of sides of a right triangle. In other words, we’ll find the hypotenuse length for right triangles with side lengths 2 &amp; 3, 3 &amp; 4, 4 &amp; 5, etc. Recall the Pythagorean theorem: \\[a^2 + b^2 = c^2\\] In R: # Make the vector of values: triangle_sides &lt;- c(2, 3, 4, 5, 6, 7) # Create the loop to calculate the hypotenuses: for (i in 1:(length(triangle_sides) - 1)) { hypotenuse = sqrt(triangle_sides[i]^2 + triangle_sides[i + 1]^2) print(hypotenuse) } ## [1] 3.605551 ## [1] 5 ## [1] 6.403124 ## [1] 7.81025 ## [1] 9.219544 In Python: Recall: Python indexing starts at ZERO (i.e., the first element in a vector is referenced with vec[0]), and the syntax for raising something to a power is ** (e.g. x**2). A weird one: the range() function in Python “…returns a sequence of numbers, starting from 0 by default, and increments by 1 (by default), and stops before a specified number.” So to create a sequence 0, 1, 2, 3, in Python you can use range(4). # Import math library (sqrt() function is not native in Python): import math # Make the vector of values: triangle_sides = [2, 3, 4, 5, 6, 7] # Create the loop to calculate the hypotenuses: index_no = range(0, len(triangle_sides) - 1) for i in index_no: hypotenuse = math.sqrt(triangle_sides[i]**2 + triangle_sides[i + 1]**2) print(hypotenuse) ## 3.605551275463989 ## 5.0 ## 6.4031242374328485 ## 7.810249675906654 ## 9.219544457292887 What does that index_no vector contain? It’s a sequence starting at 0 and increasing by 1 (the default increment) to a value below len(triangle_sides) - 1. Since the length of the triangle_sides vector is 6, that value is 5…and the vector continues to the value before the end value in range(). Frankly, it seems very weird to me, but that’s what it’s doing. demo_vec = range(4) for i in demo_vec: print(i) ## 0 ## 1 ## 2 ## 3 8.4 Iteration with conditions In the examples of for loops so far, we did the same repeated thing to each element. Sometimes, however, we’ll want to change what we do to an element based on some characteristic - like in the monster parade example above, where the looped assigned a different accessory based on the monster shape. We can add conditions within a for loop to specify what thing we want to to elements based on some condition we set. The general anatomy of that process looks like this: [ANATOMY OF A FOR LOOP WITH CONDITIONS] Let’s consider some examples. 8.4.0.1 Example: Feed the pets. Given our vector of 3 pets below, write a for loop that returns “kibble” if it is a dog, but “alfalfa” if it is a horse. The pets are: dog, horse, dog In R: # Make the vector of pets: pet_type &lt;- c(&quot;dog&quot;, &quot;horse&quot;, &quot;dog&quot;) # Run it through the for loop: for (i in pet_type) { if(i == &quot;dog&quot;) { print(&quot;kibble&quot;) } else { print(&quot;alfalfa&quot;) } } ## [1] &quot;kibble&quot; ## [1] &quot;alfalfa&quot; ## [1] &quot;kibble&quot; In Python: # Make the vector of pets: pet_type = [&#39;dog&#39;, &#39;horse&#39;, &#39;dog&#39;] # Run it through the for loop: for i in pet_type: if i == &#39;dog&#39;: print(&quot;kibble&quot;) else: print(&quot;alfalfa&quot;) ## kibble ## alfalfa ## kibble 8.4.0.2 Example: Bins For a vector of values (2, 6, 1, 18), if the value is four or less 5, return “low,” if the value is great than four and less than 12, return “moderate,” and if the value is greater than or equal to 12 return “high.” In R: # Make the vector: numbers &lt;- c(2, 6, 1, 18) # Run it through the loop with conditions: for (i in numbers) { if (i &lt;= 4) { print(&quot;low&quot;) } else if (i &gt; 4 &amp; i &lt; 12) { print(&quot;moderate&quot;) } else { print(&quot;high&quot;) } } ## [1] &quot;low&quot; ## [1] &quot;moderate&quot; ## [1] &quot;low&quot; ## [1] &quot;high&quot; In Python: Note that we use elif for the else-if statement in the body. numbers = [2, 6, 1, 18] for i in r.numbers: if i &lt;= 4: print(&quot;low&quot;) elif 12 &gt; i &gt;= 4: print(&quot;moderate&quot;) else: print(&quot;high&quot;) ## low ## moderate ## low ## high 8.5 While loop A while loop will execute a command (or set of commands) as long as a condition is true. Once the condition is not true, the loop is exited. While loop in R: # Initiate i &lt;- 0 # Create a while loop that exits once i is NOT less than 5 while (i &lt; 5) { print(i) i = i + 1 } ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 While loop in Python: i = 0 while i &lt; 5: print(i) i = i + 1 ## 0 ## 1 ## 2 ## 3 ## 4 8.5.1 A while loop break statement Using a break statement, we can write a while loop that is exited if the break condition occurs, even if the while condition is still true. 8.6 R / Python side-by-side comparisons Example R Python Basic for loop for (i in vec) { print(i) } for i in vec: print(i) For loop with condition for (i in vec) { if i &gt; 5 { print(\"this\") } else { print(\"that\") } } python example "],["functions.html", "Chapter 9 Functions 9.1 Function components 9.2 Writing simple functions 9.3 Functions with conditionals 9.4 Functions with iteration 9.5 Useful function features 9.6 Testing functions 9.7 Iterating functions 9.8 Resources on building, testing, &amp; documenting functions", " Chapter 9 Functions Writing functions to implement algorithms is a fundamental skill for every environmental data scientist. Functions can reduce repetition, increase efficiency and elegance, and facilitate reuse and sharing. Functions built by other developers will be ingrained into your code, but it’s also critical that you can build, test, document, and share your own functions. This chapter covers: Function structure Writing basic functions Nested functions Functions with iteration and conditions Useful function features Testing Documentation Applied examples 9.1 Function components At the most basic level, a function takes an input, does something to it (a calculation, transformation, etc.), and returns an output. For example, we can write a function that doubles the input value. In function notation seen in math, that would be: \\[f(x) = 2x\\] where \\(x\\) is the input, and \\(f(x)\\) is the output. The function \\(f\\) acts on input \\(x\\) by doubling the input value. How can we create a function to do the same thing in R? An R function would look like this: double_it &lt;- function(x) { 2*x } What are these different pieces of that function? function name: Here, the function is named double_it formals: The function(x) piece defines the function formals (arguments / parameters). This function expects a single input argument, x (you can check what the formals are using formals(function_name)). body: here, { 2*x } is the body of the function - that’s where we tell it what to do with the inputs. Note the braces (i.e. squiggly brackets) are often on separate lines from the algorithm itself. Try out the function by inputting both a single value, and a vector of values. Note that vectorization is the default - meaning that the function is applied to each element in a vector. double_it(x = 20) ## [1] 40 vec &lt;- c(2, 4, 50) # Create a vector with multiple values double_it(vec) # Function acts on each element in the vector ## [1] 4 8 100 Those are the main pieces. But don’t worry, it gets a lot more interesting. Let’s start by writing a few of our own functions. 9.1.1 A note on names It’s important to be thoughtful when naming functions. We generally want to follow standard practices for good names (concise, descriptive, code and coder-friendly), but you may also consider the following: - Start with a verb that describes what the function does (e.g. sort, build, predict) - End with a noun describing the thing it works with or creates (e.g. image, model, mass) - Combine them with a coder-friendly case (like lower_snake_case) For example, here are some suggestions that may be useful function names: `sum_imports`, `predict_offsets`, `plot_simulations` In contrast, here are some function names that may be less useful, memorable, and intuitive for you and collaborators: `fun_1`, `calc`, `x2` It is likely that there will be a tradeoff between conciseness and descriptiveness. While there aren’t rules about naming functions, I recommend erring on the side of descriptiveness to make reading and writing code a bit more intuitive. With tab-completion, the decrease in efficiency is minimal. 9.2 Writing simple functions Let’s practice writing a few simple functions using established relationships in environmental science. 9.2.1 Example 1: Fish standard weight “Standard weight” is how much we expect a fish to weigh, give the species and fish length, and the nonlinear relationship is given by: \\[W=aL^b\\] where \\(L\\) is total fish length (centimeters), \\(W\\) is the expected fish weight (grams), and \\(a\\) and \\(b\\) are species-dependent parameter values. Write a function to calculate fish weight based on \\(a\\), \\(b\\), and fish length, then estimate the weight of several fish based on the following parameter estimates for Hawaiian fish from Peyton et al. (2016): Table 9.1: Parameter estimates for selected Hawaiian fish from Peyton et al. (2015). Scientific name Common name a b Chanos chanos Milkfish 0.0905 2.52 Sphyraena barracuda Great barracuda 0.0181 3.27 Caranx ignobilis Giant trevally 0.0353 3.05 Function: predict_weight &lt;- function(a, length, b) { a*(length^b) } Using the function: Estimate the mass of a 160 cm long great barracuda. Estimate the mass of a 118 cm long milkfish. Thinking ahead: Does this pass your smell test for a user-friendly and user-helpful function? How might we make this function simpler for a user? For example, maybe a user can input the species, and the parameters \\(a\\) and \\(b\\) can be correctly sourced from a table? We’ll learn how to add this kind of functionality in upcoming sections. 9.2.2 Example 2: Wind turbines The full power in wind hitting a turbine is: \\[P = 0.5\\rho Av^3\\] where \\(P\\) is power in Watts (joules/second), \\(\\rho\\) is the air density (kg/m3), \\(A\\) is the area covered by the turbine blades (square meters), and \\(v\\) is the wind velocity (m/s). However, the Betz Limit means that turbines can only collect ~60% of the total wind power, which updates the theoretical “collectable” power (before accounting for inefficiencies, losses, etc.) to: \\[P = 0.3\\rho Av^3\\] Write a function to calculate maximum collectable wind power (Watts) by a turbine requiring three inputs: Air density (in kg/m3) Rotor radius (in meters) Wind velocity (in m/s) Write the function: calc_windpower &lt;- function(rho, radius, windspeed) { 0.3*rho*pi*(radius^2)*(windspeed^3) } Can we clean this up a bit by calculating the area first, within the function? Sure! calc_windpower &lt;- function(rho, radius, windspeed) { # Calculate turbine area (meters squared): turbine_area = pi*(radius^2) # Calculate collectable power: 0.3*rho*turbine_area*(windspeed^3) } Now let’s use the function we’ve created. The largest turbine in the world (as of March 2021) is the GE Haliade-X, an offshore turbine prototype in Rotterdam, the Netherlands, with a 220 meter rotor diameter. Assuming a windspeed of 7.7 m/s (based on long-term averages for North sea North Sea platforms from Coelingh, Wijk, and Holtslag (1998)) and an air density of 1.225 kg/m3 (at sea level), estimate the wind power that can be collected. calc_windpower(rho = 1.225, radius = 110, windspeed = 7.7) # Watts ## [1] 6377710 9.3 Functions with conditionals In the examples above, we change input values, but what the function does doesn’t change based on those input values. Sometimes, we’ll want our function to do something different (e.g. a different calculation, use a different constant value) based on the input values. 9.4 Functions with iteration 9.5 Useful function features 9.6 Testing functions 9.7 Iterating functions 9.8 Resources on building, testing, &amp; documenting functions Ch. 6 - Functions in Advanced R by Hadley Wickham "],["tidyverse.html", "Chapter 10 Data wrangling &amp; viz in the tidyverse", " Chapter 10 Data wrangling &amp; viz in the tidyverse "],["troubleshooting.html", "Chapter 11 Troubleshooting", " Chapter 11 Troubleshooting "],["references.html", "References", " References Coelingh, J. P., A. J. M. van Wijk, and A. A. M. Holtslag. 1998. “Analysis of Wind Speed Observations on the North Sea Coast.” Journal of Wind Engineering and Industrial Aerodynamics 73 (2): 125–44. https://doi.org/10.1016/S0167-6105(97)00285-7. Lowndes, Julia S. Stewart, and Allison Horst. 2020. “Tidy Data for Efficiency, Reproducibility and Collaboration.” Openscapes. https://www.openscapes.org/blog/2020/10/12/tidy-data/. Peyton, K. A., T. S. Sakihara, L. K. Nishiura, T. T. Shindo, T. E. Shimoda, S. Hau, A. Akiona, and K. Lorance. 2016. “Length–Weight Relationships for Common Juvenile Fishes and Prey Species in Hawaiian Estuaries.” Journal of Applied Ichthyology 32 (3): 499–502. https://doi.org/10.1111/jai.12957. Wickham, Hadley. 2014. “Tidy Data.” Journal of Statistical Software 59 (10). https://doi.org/10.18637/jss.v059.i10. "]]
